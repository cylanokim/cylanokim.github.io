--- 
title: "간단한 RDB 만들기"
description: 간단한 DB 설계를 해보고, 이를 구현해보자
author: cylanokim
date: 2025-12-09 12:00:00 +0800
categories: [BACK_END]
tags: [RDB, ERD, DB]
pin: true
math: true
mermaid: true
---

- Primary Key (PK)의 특징
    - 테이블 안에서 각 row를 유일하게 식별하는 컬럼
    - 중복❌, NULL❌, 테이블당 1개, 인덱스 자동 생성

- Foreign Key (FK)의 특징
    - 다른 테이블의 PK 혹은 UK를 참조하는 컬럼
    - FK는 항상 **"참조하는 쪽"**에 있음
    - 즉 `users.user_id` → PK, `orders.user_id` → FK 



## 1. users
```sql
CREATE TABLE users (
  user_id BIGINT UNSIGNED NOT NULL AUTO_INCREMENT,
  email   VARCHAR(255) NOT NULL,
  name    VARCHAR(100) NOT NULL,
  created_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
  PRIMARY KEY (user_id),
  UNIQUE KEY uk_users_email (email)
) ENGINE=InnoDB;
```
- 왜 email은 uk_users_email이라 따로 명시하는 것일까?
    - email이 단순 컬럼이 아니라 **제약 조건(constraint), 인덱스 이름** 이기 때문
    - 위와 같이 입력 시, **uk_users_email이라는 객체**를 생성 → 에러 메시지가 명확하고 유지 보수가 유리

- 네이밍 컨벤션 

| 접두어    | 의미          |
| ------ | ----------- |
| `pk_`  | Primary Key |
| `uk_`  | Unique Key  |
| `fk_`  | Foreign Key |
| `idx_` | 일반 Index    |


## 2. products
```sql
CREATE TABLE products (
  product_id BIGINT UNSIGNED NOT NULL AUTO_INCREMENT,
  sku        VARCHAR(50) NOT NULL,
  name       VARCHAR(200) NOT NULL,
  price      DECIMAL(12,2) NOT NULL,
  created_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
  PRIMARY KEY (product_id),
  UNIQUE KEY uk_products_sku (sku)
) ENGINE=InnoDB;
```

## 3. orders (users 1: N orders)
```sql
CREATE TABLE orders (
  order_id BIGINT UNSIGNED NOT NULL AUTO_INCREMENT,
  user_id  BIGINT UNSIGNED NOT NULL,
  status   ENUM('CREATED','PAID','CANCELLED') NOT NULL DEFAULT 'CREATED',
  ordered_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
  PRIMARY KEY (order_id),
  KEY idx_orders_user_id (user_id),
  CONSTRAINT fk_orders_user
    FOREIGN KEY (user_id) REFERENCES users(user_id)
    ON DELETE RESTRICT
    ON UPDATE CASCADE
) ENGINE=InnoDB;
```

주요 sql 문 의미 분석

- `KEY idx_orders_user_id (user_id)` :  orders.user_id 컬럼에 일반 인덱스(non-unique idnex)를 추가하는 것
    - KEY: MySQL에서 INDEX의 명칭
    - user_id를 새로운 index로 추가하면 빠른 검색 가능 (B-Tree, O(logN))
    - 한 유저에 대한 여러 orders가 가능하므로 **KEY (user_id)**
    - 즉 `orders.user_id`에 대해 `idx_orders_user_id`라는 이름의 중복 허용 인덱스를 생성하는 것
- `CONSTRAINT`는 DB의 제약 조건을 의미. 그리고 그 제약 조건 이름이 fk_orders_user
- `FOREIGN KEY (user_id)...`: users 테이블의 user_id를 참조하는 FK를 정의. unique가 없으므로 부모와 1:N
- `ON DELETE RESTRICT` → 부모 테이블 (users)의 row를 삭제를 할 수 있나 없나?
    - orders에 user_id=1인 row가 있다고 가정하자

    ✅ 삭제 가능한 경우
    ```sql
    DELETE FROM users WHERE user_id = 100;
    ```
    ❌ 삭제 불가한 경우
    ```sql
    DELETE FROM users WHERE user_id = 1;
    ```
    ```text
    Cannot delete or update a parent row:
    a foreign key constraint fails
    ```
- `ON UPDATE CASCADE`는 부모 테이블(users)의 PK 변경 → 자식 FK 자동으로 같이 바꿔줌
- 예시
    - users (user_id=1, ...)
    - orders (order_id=10, user_id=1, ...), (order_id=11, user_id=1, ...)
    ```sql
    UPDATE users SET user_id = 100 WHERE user_id = 1;
    ```
    `ON UPDATE CASCADE`가 있으면 결과는 자동으로
    - `users.user_id`: 1 → 100
    - `orders.user_id` : 1 → 100 (order_id=10,1...). 무결성이 깨지지 않게 자동 변경


## 4. 주문 항목 (orders 1 : N order_items, products 1 : N order_items)

```sql
CREATE TABLE order_items (
  order_item_id BIGINT UNSIGNED NOT NULL AUTO_INCREMENT,
  order_id      BIGINT UNSIGNED NOT NULL,
  product_id    BIGINT UNSIGNED NOT NULL,
  qty           INT UNSIGNED NOT NULL,
  unit_price    DECIMAL(12,2) NOT NULL, -- 주문 시점 가격 스냅샷
  PRIMARY KEY (order_item_id),
  KEY idx_items_order_id (order_id),
  KEY idx_items_product_id (product_id),
  CONSTRAINT fk_items_order
    FOREIGN KEY (order_id) REFERENCES orders(order_id)
    ON DELETE CASCADE
    ON UPDATE CASCADE,
  CONSTRAINT fk_items_product
    FOREIGN KEY (product_id) REFERENCES products(product_id)
    ON DELETE RESTRICT
    ON UPDATE CASCADE
) ENGINE=InnoDB;
```

## 5. ERD

<div style="text-align: center;">
  <img src="/assets/img/erd.PNG" alt="ERD" width="500">
</div>
